#pragma once

#include <stdio.h>
#include <arrayfire.h>
using namespace af;

static inline size_t readline(char* ptr, size_t maxbytes, FILE* f) {
    size_t bytes = 0;
    for (size_t i = 0; i < maxbytes; ++i) {
        if (feof(f)) { return bytes; }
        int c = fgetc(f);
        if (c == '\n') { return bytes; }
        ptr[bytes++] = c;
    }
    return bytes;
}

static inline array load_gray_ppm(const char* fname) {
    // open
    FILE* f = fopen(fname, "rb");
    if (!f) { throw af::exception("unable to open image file"); }

    char buffer[1024];

    // ignore first line (or 256 bytes)
    readline(buffer, 256, f);

    // ignore comments
    readline(buffer, sizeof(buffer), f);
    while (buffer[0] == '#') {
        readline(buffer, sizeof(buffer), f);
    }

    // read image size (two integers on same line)
    char* ptr;
    unsigned M = strtol(buffer, &ptr, 0);
    unsigned N = atoi(ptr);
    // read range, but ignore actual value (one integer on new line)
    readline(buffer, sizeof(buffer), f);

    // read RGB image data
    unsigned char* rgb = new unsigned char[3 * M * N];
    if (fread(rgb, sizeof(*rgb), 3 * M * N, f) != 3 * M * N) {
        throw af::exception("unable to read entire image data");
    }
    fclose(f);

    // average channels to produce gray
    float* gray = new float[M * N];
    for (unsigned i = 0; i < M * N; ++i) {
        gray[i] = (rgb[3 * i] + rgb[3 * i + 1] + rgb[3 * i + 2]) / 3.0f / 255.0f;
    }
    delete[] rgb;

    array image = array(M, N, gray);
    delete[] gray;
    return image.T();
}


// Split a 'packed' 3xNxM image into 3 separate channel matrices.
// also transposes outputs to 'normal' MxNx1.
static inline void channel_split_T(array& rgb, array& outr, array& outg, array& outb) {
    dim4 ss = rgb.dims(); // expecting 3xNxM
    array ii = array(rgb, ss[2] * ss[1], 3);
    outr = array(ii.col(0), ss[1], ss[2]).T();
    outg = array(ii.col(1), ss[1], ss[2]).T();
    outb = array(ii.col(2), ss[1], ss[2]).T();
}


// Custom transform (3xNxM->MxNx3)
static inline array reshape_ppm(array& rgb) {
    array rr, gg, bb;
    channel_split_T(rgb, rr, gg, bb);
    return join(2, rr, gg, bb);
}


// return is row-major, packed RGB, Transposed!!!
static inline array load_rgb_ppm(const char* fname) {
    // open
    FILE* f = fopen(fname, "rb");
    if (!f) { throw af::exception("unable to open image file"); }

    char buffer[1024];

    // ignore first line (or 256 bytes)
    readline(buffer, 256, f);

    // ignore comments
    readline(buffer, sizeof(buffer), f);
    while (buffer[0] == '#') {
        readline(buffer, sizeof(buffer), f);
    }

    // read image size (two integers on same line)
    char* ptr;
    unsigned M = strtol(buffer, &ptr, 0);
    unsigned N = atoi(ptr);
    // read range, but ignore value (one integer on new line)
    readline(buffer, sizeof(buffer), f);

    // read packed RGB image data
    size_t bytes = 3 * M * N * sizeof(unsigned char);
    unsigned char* packed = (unsigned char*)malloc(bytes);
    if (fread(packed, bytes, 1, f) < 1) {
        throw af::exception("unable to read entire image data");
    }
    fclose(f);

    // unpack and convert channels
    float* unpacked = (float*)malloc(3 * M * N * sizeof(float));
    int step = N * M - 1;
    for (unsigned i = 0; i < M * N; ++i) {
        unpacked[i + 0 * step] = packed[3 * i + 0] / 255.0f;
        unpacked[i + 1 * step] = packed[3 * i + 1] / 255.0f;
        unpacked[i + 2 * step] = packed[3 * i + 2] / 255.0f;
    }
    free(packed);

    array image(3, M, N, unpacked);
    free(unpacked);
    return reshape_ppm(image);
}
